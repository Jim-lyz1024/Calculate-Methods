1、牛顿法：

#include<stdio.h>
#include<math.h>
double func(double x)   //函数
{return x*x*x-x-1;}

double func1(double x)  //导函数
{return 3*x*x-1;}

double root(double num)
{
double x0,x1;
x0=num;
if(func1(x0)==0.0)  //若通过初值，函数返回值为0 　　
{printf("迭代过程中导数为0!\n");return x0;}
x1=x0-func(x0)/func1(x0);
while((fabs(x1-x0))>1e-6)
{
x0=x1;
x1=x0-func(x0)/func1(x0);
printf("x=%.4lf\n",x1);
}
printf("该方程在1.5附近的根为:%lf。\n",x1);
return x1;
}

main()
{
root(1.5);
}


2、埃特金加速迭代
#include<stdlib.h>
#include<stdio.h>
#include<math.h>
#define cha 1e-4
int main()
{
    float x,new_x[2],old_x;
    int count=0;
    printf("请输入x0:");
    scanf("%f",&x);
    while(fabs(x-old_x)>cha||count==0)
    {
     old_x = x;
     new_x[0] = pow(x+1,1.0/3);
     new_x[1] = pow(new_x[0]+1,1.0/3);
     x =(old_x*new_x[1]-new_x[0]*new_x[0])/(old_x-2*new_x[0]+new_x[1]);
     printf("%f\n",x);
     count++;
    }
    printf("迭代次数为：%d",count);
    return 0;
}

3、
#include<stdlib.h>
#include<stdio.h>
#include<math.h>
#define cha 1e-4
float f(float x)
{
    float y;
    y = x-pow(x,3)+1;
    return y;
}
int main()
{
    float x0,x1,old_x0,old_x1;
    int count = 0;
    printf("请输入x0：");
    scanf("%f",&x0);
    printf("请输入x1：");
    scanf("%f",&x1);
    while(fabs(old_x1-old_x0)>cha || count == 0)
    {
        old_x0 = x0;
        old_x1 = x1;
        x1 = x1 - (f(x1)*(x1-x0))/(f(x1)-f(x0));
        x0 = old_x1;
        printf("%f\n",x1);
        count++;
    }
    printf("进行的次数为:%d\n",count);
    printf("最终结果为:%f",x1);
    return 0;
}
